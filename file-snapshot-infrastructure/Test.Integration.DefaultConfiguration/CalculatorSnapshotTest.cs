using FluentAssertions;
using Scand.StormPetrel.FileSnapshotInfrastructure;
using Scand.StormPetrel.FileSnapshotInfrastructure.Attributes;
using Test.Integration.Shared;

namespace Test.Integration.DefaultConfiguration;

/// <summary>
/// Demonstrates and tests use cases of Storm Petrel rewrites with the default configuration of the File Snapshot Infrastructure.
/// </summary>
public sealed class CalculatorSnapshotTest
{
    /// <summary>
    /// Reads expected text from JSON file, serializes actual <see cref="AddResult"/> instance to JSON snapshot
    /// and then asserts their equality. This approach has several disadvantages compared to
    /// "keeping expected baselines as C# code instances." what Scand.StormPetrel.Generator supports OOTB to rewrite.
    /// However, in some cases, this approach might be beneficial.
    /// So, this test demonstrates how it can be implemented via StormPetrel to rewrite text file snapshots.
    /// </summary>
    [Fact]
    public static void AddTest()
    {
        //Arrange
        //Read JSON text from the `CalculatorSnapshotTest.Expected\AddTest.json` file, which corresponds to
        //the default configuration of the Scand.StormPetrel.FileSnapshotInfrastructure NuGet package.
        //This file must exist before executing this test or its AddTestStormPetrel test auto-generated by Scand.StormPetrel
        //because the default configuration (see details in appsettings.StormPetrel.json) does not specify
        //the snapshot file extension.
        var expectedFileJsonSnapshot = SnapshotProvider.ReadAllText();

        //Act
        var actualFileJsonSnapshot = Calculator
                                        .Add(2, 2) //Call method being tested.
                                        .ToJsonText(); //Serialize result to json. Any implementation may be used here.

        //Assert
        actualFileJsonSnapshot.Should().Be(expectedFileJsonSnapshot);
    }

    [Fact]
    public static void GetLogoTest()
    {
        //Arrange
        var expectedFileBytesSnapshot = SnapshotProvider.ReadAllBytes();

        //Act
        var actualFileBytesSnapshot = Calculator.GetLogo();

        //Assert
        actualFileBytesSnapshot.Should().Equal(expectedFileBytesSnapshot);
    }

    [Theory]
    [InlineData("2+2", 2, 2)]
    [InlineData("5-1", 5, -1)]
    public void AddTestViaUseCases(string useCaseId, int a, int b)
    {
        //Arrange
        var expectedFileJsonSnapshot = SnapshotProvider.ReadAllText(useCaseId);

        //Act
        var actualFileJsonSnapshot = Calculator.Add(a, b).ToJsonText();

        //Assert
        actualFileJsonSnapshot.Should().Be(expectedFileJsonSnapshot);
    }

    [Theory]
    [MemberData(nameof(AddTestViaUseCaseParameterWithAttributeData))]
    public void AddTestViaUseCaseParameterWithAttribute(int a, int b, [UseCaseId] string myParamForUseCase)
    {
        //Arrange
        var expectedFileJsonSnapshot = SnapshotProvider.ReadAllText(myParamForUseCase);

        //Act
        var actualFileJsonSnapshot = Calculator.Add(a, b).ToJsonText();

        //Assert
        actualFileJsonSnapshot.Should().Be(expectedFileJsonSnapshot);
    }

    [Fact]
    public static void GetLogoAsStreamTest()
    {
        //Arrange
        using var expectedStreamSnapshot = SnapshotProvider.OpenReadWithShareReadWrite();

        //Act
        using var actualStreamSnapshot = Calculator.GetLogoAsStream();

        //Assert
        //Other stream assertion approaches (checksum or whatever) can be used here
        expectedStreamSnapshot.ToByteArray().Should().Equal(actualStreamSnapshot.ToByteArray());
    }

    public static TheoryData<int, int, string> AddTestViaUseCaseParameterWithAttributeData =>
    new()
    {
        { 1, 2, "MyUseCase_1+2" },
        { 2, -2, "MyUseCase_2-2" },
    };
}