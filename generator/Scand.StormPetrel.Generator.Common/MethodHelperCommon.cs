using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Scand.StormPetrel.Generator.Common
{
    internal class MethodHelperCommon
    {
        private static bool IsStatic(MethodDeclarationSyntax method)
            => method.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        private static bool IsStatic(PropertyDeclarationSyntax property)
            => property.Modifiers.Any(x => x.IsKind(SyntaxKind.StaticKeyword));
        public static IEnumerable<string> GetTestAttributeNames(MethodDeclarationSyntax method)
            => GetAttributes(method, x => SupportedMethodInfo.Instance.AttributeNames.Contains(x.Name.ToString()))
                .Select(x => x.Name.ToString());
        public static IEnumerable<string> GetTestCaseAttributeNames(MethodDeclarationSyntax method)
            => GetAttributes(method, x => SupportedMethodInfo.Instance.AttributeNamesForTestCase.Contains(x.Name.ToString()))
                .Select(x => x.Name.ToString());
        public static AttributeSyntax GetTestCaseSourceAttribute(MethodDeclarationSyntax method)
            => GetAttributes(method, x => SupportedMethodInfo.GetTestCaseSourceKind(x.Name.ToString()).HasValue)
                .FirstOrDefault();
        private static IEnumerable<AttributeSyntax> GetAttributes(MethodDeclarationSyntax method, Func<AttributeSyntax, bool> predicate)
            => GetAttributePairs(method.AttributeLists, predicate)
                .Select(x => x.Attribute);
        public static IEnumerable<(AttributeListSyntax AttributeList, AttributeSyntax Attribute)> GetAttributePairs(SyntaxList<AttributeListSyntax> attributeList, Func<AttributeSyntax, bool> predicate) =>
            attributeList
                .SelectMany(a => a.Attributes
                                    .Where(b => predicate(b))
                                    .Select(b => (a, b)));
        public static bool IsExtensionMethod(MethodDeclarationSyntax method) =>
            method.ParameterList?.Parameters.FirstOrDefault()?.Modifiers.Any(SyntaxKind.ThisKeyword) == true;
        /// <summary>
        /// CAUTION: `private protected` is treated as `private` because `private protected` is impossible case within static classes where extension methods are only allowed.
        /// </summary>
        /// <param name="memberModifiers"></param>
        /// <returns></returns>
        public static bool HasPrivateOrNoAccessModifiers(SyntaxTokenList memberModifiers) =>
            memberModifiers.FirstOrDefault(x => x.IsKind(SyntaxKind.PrivateKeyword)) != default
                || !memberModifiers.Any(x => x.IsKind(SyntaxKind.PublicKeyword) || x.IsKind(SyntaxKind.InternalKeyword) || x.IsKind(SyntaxKind.ProtectedKeyword));
        /// <summary>
        /// CAUTION: see <see cref="HasPrivateOrNoAccessModifiers(SyntaxTokenList)"/> summary.
        /// </summary>
        /// <param name="method"></param>
        /// <returns></returns>
        public static bool HasPrivateOrNoAccessModifiers(MethodDeclarationSyntax method) => HasPrivateOrNoAccessModifiers(method.Modifiers);
        public static bool IsExpectedVarInvocationExpressionCandidate(MethodDeclarationSyntax method)
            => IsStatic(method)
                && !GetTestAttributeNames(method).Any()
                && method.ReturnType != null
                && method.ReturnType.ToString() != "void"
                && method.ReturnType.ToString().IndexOf("Task", StringComparison.Ordinal) < 0
                //ignore extension methods to avoid duplicated extension method and thus target test project compilation failure
                && !IsExtensionMethod(method);
        public static bool IsExpectedVarInvocationExpressionCandidate(PropertyDeclarationSyntax property)
            => IsStatic(property)
                && property.Type != null
                && property.Type.ToString().IndexOf("Task", StringComparison.Ordinal) < 0;
        public static IEnumerable<MethodDeclarationSyntax> GetMethods(ClassDeclarationSyntax classDeclarationSyntax) =>
            classDeclarationSyntax
                .ChildNodes()
                .OfType<MethodDeclarationSyntax>();
        public static bool TryCastAsInvocationExpressionCandidate(SyntaxNode node, out MethodDeclarationSyntax method, out PropertyDeclarationSyntax property, out ClassDeclarationSyntax parent)
        {
            method = null;
            property = null;
            parent = node.Parent as ClassDeclarationSyntax;
            if (parent == null)
            {
                return false;
            }
            //Ignore auto generated file from xUnit v3
            if (node.SyntaxTree.FilePath.EndsWith("XunitAutoGeneratedEntryPoint.cs", StringComparison.OrdinalIgnoreCase))
            {
                return false;
            }
            if (node is MethodDeclarationSyntax methodDeclaration
                    && IsExpectedVarInvocationExpressionCandidate(methodDeclaration))
            {
                method = methodDeclaration;
                return true;
            }
            else if (node is PropertyDeclarationSyntax propertyDeclaration
                        && IsExpectedVarInvocationExpressionCandidate(propertyDeclaration))
            {
                property = propertyDeclaration;
                return true;
            }
            return false;
        }
    }
}
